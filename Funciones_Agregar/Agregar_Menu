void agregar(struct ministerio *ministerio){
    int opcion;

    printf("Marque una opcion: \n\n");
    printf("Opcion 1: Agregar persona\n");
    printf("Opcion 2: Agregar denuncia\n");
    printf("Opcion 3: Agregar carpeta investigativa\n");
    printf("Opcion 4: Agregar causa\n");
    printf("Opcion 5: Agregar involucrados\n");
    scanf("%d", &opcion);
    /*El fiscal tendra que elegir la opcion a agregar, ya sea una persona, denuncia, carpeta investigativa*/

    if (opcion == 1) {
    /*Opcion 1 agregar persona*/


        struct persona *nuevaPersona = (struct persona *)malloc(sizeof(struct persona));
        /*Se crea el struct persona y se le asigna memoria de inmediato, si el asignar memoria falla finaliza el programa*/
        char palabra[100];
        int rol, contrasenaFiscalJuez = 111111 ; 
        
        if(nuevaPersona == NULL){
            printf("Error al asignar memora");
            return;
        }

        printf("Ingrese rut del denunciante: \n");
        
        while(1){
            scanf(" %[^\n]", palabra);
            if(strlen(palabra) == 0){
                printf("El RUT no puede estar vacio, intente nuevamente\n");
            } else if(strlen(palabra) > 99){
                printf("El RUT ingresado es demasiado largo, intente nuevamente\n");
            } else if (buscarPersonaPorRut(ministerio->personas, palabra) != NULL) {
                printf("Ya existe una persona con ese RUT. No se puede agregar duplicado.\n");
                free(nuevaPersona);
                return;
            } else {
                break;
            }
        }
        nuevaPersona->rut = (char *)malloc(strlen(palabra) + 1);
        strcpy(nuevaPersona->rut, palabra);
        
        printf("Ingrese nombre del denunciante: \n");
        while(1){
            scanf(" %[^\n]", palabra);
            if(strlen(palabra) == 0){
                printf("El nombre no puede estar vacio, intente nuevamente\n");
            } else if(strlen(palabra) > 100){
                printf("El nombre no puede ser tan largo, intente nuevamente");
            } else {
                break;
            }
        } 
        nuevaPersona->nombre = (char *)malloc(strlen(palabra) + 1);
        strcpy(nuevaPersona->nombre, palabra);

        printf("Ingrese apellido del denunciante: \n");
        while(1){
            scanf(" %[^\n]", palabra);
            if(strlen(palabra) == 0){
                printf("El apellido no puede estar vacio, intente nuevamente\n");
            } else if(strlen(palabra) > 100){
                printf("El apellido no puede ser tan largo, intente nuevamente\n");
            } else {
                break;
            }
        }         
        nuevaPersona->apellido = (char *)malloc(strlen(palabra) + 1);
        strcpy(nuevaPersona->apellido, palabra);

        printf("Ingrese rol del denunciante (1, 2 o 3): \n");
        while (1) {
            if (scanf("%i", &rol) != 1) {
                printf("Rol inválido. Intente nuevamente:\n");
                while (getchar() != '\n'); // Limpiar buffer
                continue;
            }
            if (rol >= 1 && rol <= 3) break;
            
            printf("Rol inválido. Se asignará rol 1 por defecto.\n");
            rol = 1;
            break;
        }
                
        if(rol > 3 || rol < 1){
            printf("Se ingreso rol incorrecto, se le asignara rol 1\n");
            rol = 1;
        }
        
        if (rol == 2 || rol == 3) {
            int contrasenaIngresada;
        
            printf("Ingrese la contraseña del sistema: \n");
            scanf(" %i", &contrasenaIngresada);
        
            if (contrasenaIngresada != contrasenaFiscalJuez) {
                printf("Contraseña incorrecta, se ingresará como Usuario Común\n");
                nuevaPersona->rol = 1;
                nuevaPersona->contrasena = 0;
            } else {
                nuevaPersona->rol = rol;
                nuevaPersona->contrasena = contrasenaIngresada;
            }
        } else {
            /* Para roles distintos a 2 y 3 */
            nuevaPersona->rol = rol;
            nuevaPersona->contrasena = 0;
        }

        nuevaPersona->denuncias = NULL; 

        agregarPersonas(&ministerio->personas, nuevaPersona); 
        printf("La persona fue agregara con exito.\n");
        /*Funcion agregarPersonas recorre la lista de personas que se encuentra en ministerio para asi agregar a la nueva persona al final de la lista*/
    }

    else if(opcion == 2){
    /*Opcion 2 agregar denuncia */

        char rutDenunciante[20];
        char rutDenunciado[20];
        char palabra[100];
        
        printf("Ingrese RUT del denunciante\n");
        while(1){
            scanf(" %[^\n]", rutDenunciante);
            if(strlen(rutDenunciante) == 0){
                printf("El RUT no puede estar vacio, intente nuevamente\n");
            } else if(strlen(rutDenunciante) > 20){
                printf("El RUT es demasiado largo, intente nuevamente\n");
            } else {
                break;
            }
        }
        
        printf("Ingrese RUT del denunciado\n");
        while(1){
            scanf(" %[^\n]", rutDenunciado);
            if(strlen(rutDenunciado) == 0){
                printf("El RUT no puede estar vacio, intente nuevamente\n");
            } else if(strlen(rutDenunciado) > 20){
                printf("El RUT es demasiado largo, intente nuevamente\n");
            } else {
                break;
            }
        }        
        
        struct persona *nuevoDenunciante = buscarPersonaPorRut(ministerio->personas, rutDenunciante);
        struct persona *nuevoDenunciado = buscarPersonaPorRut(ministerio->personas, rutDenunciado);
        /*Se pregunta y lee los ruts de denunciante y denunciado para asi copiar esta informacion en 2 strcut personas */

        if(nuevoDenunciante == NULL || nuevoDenunciado == NULL){
            printf("Denunciante y denunciado no encontrados, intente con un RUT valido\n");
            return;
        }
    
        struct denuncia *nuevaDenuncia = (struct denuncia *)malloc(sizeof(struct denuncia));
        
        if(nuevaDenuncia == NULL){
            printf("Error al asignar memoria");
            return;
        }
        /*Se corrobora que exita denunciante y denunciado para luego asignar memoria a la nueva denuncia (tambien se corrobora que se asigne correctamente la memoria)*/

        nuevaDenuncia->denunciante = nuevoDenunciante;
        nuevaDenuncia->denunciado = nuevoDenunciado;
        
        printf("Ingrese la fecha actual: \n");
        while (1) {
            scanf(" %[^\n]", palabra);
            if (strlen(palabra) == 0) {
                printf("La fecha no puede quedar vacía. Intente de nuevo:\n");
            } else if (strlen(palabra) > 20) {
                printf("La fecha es demasiado larga. Intente de nuevo:\n");
            } else {
                break;
            }
        }        
        nuevaDenuncia->fecha = (char *)malloc(strlen(palabra) + 1);
        strcpy(nuevaDenuncia->fecha, palabra);
        
        printf("Ingrese descripcion de la denuncia: \n");
        while (1) {
            scanf(" %[^\n]", palabra);
            if (strlen(palabra) == 0) {
                printf("La descripcion  no puede quedar vacía. Intente de nuevo:\n");
            } else if (strlen(palabra) > 20) {
                printf("La descripcion  es demasiado larga. Intente de nuevo:\n");
            } else {
                break;
            }
        }        
        nuevaDenuncia->descripcion = (char *)malloc(strlen(palabra) + 1);
        strcpy(nuevaDenuncia->descripcion, palabra);        
    
        printf("Ingrese RUC de la denuncia: \n");
        while (1) {
            scanf(" %[^\n]", palabra);
            if (strlen(palabra) == 0) {
                printf("La RUC no puede quedar vacía. Intente de nuevo:\n");
            } else if (strlen(palabra) > 200) {
                printf("La RUC es demasiado larga. Intente de nuevo:\n");
            } else {
                break;
            }
        }
        nuevaDenuncia->ruc = (char *)malloc(strlen(palabra) + 1);
        strcpy(nuevaDenuncia->ruc, palabra);    

        printf("Ingrese el tipo de denuncia: \n");
        while (1) {
            scanf(" %[^\n]", palabra);
            if (strlen(palabra) == 0) {
                printf("El tipo de denuncia no puede quedar vacío. Intente de nuevo:\n");
            } else if (strlen(palabra) > 50) {
                printf("El tipo de denuncia es demasiado largo. Intente de nuevo:\n");
            } else {
                break;
            }
        }        
        nuevaDenuncia->tipoDeDenuncia = (char *)malloc(strlen(palabra) + 1);
        strcpy(nuevaDenuncia->tipoDeDenuncia, palabra);        
        /*Se le asigna la informacion a la denuncia como la fecha, quien es el denunciante y el denunciado entre otros*/

        agregarDenunciaAPersona(rutDenunciante, ministerio, nuevaDenuncia);
        agregarDenunciaAPersona(rutDenunciado, ministerio, nuevaDenuncia);
        printf("Denuncia agregada correctamente. \n");
        /* recorrer ministerio->personas y validar que el rut sea el del denunciante o denunciado (en cada caso) si es el rut, agregar a la lista de denuncias  */
        /*buscar el rut y recorrer la lista de denuncias que tiene, agregar */
    } 
    
    else if(opcion == 3){
        
        char palabra[300];
        int tipoDato;
        struct datosCarpeta *nuevaCarpeta;
        
        
        nuevaCarpeta = (struct datosCarpeta *)malloc(sizeof(struct datosCarpeta));
        
        if(nuevaCarpeta == NULL){
            printf("Error al asignar memoria");
            return;
        }
        /*Se le asigna memoria a la nueva caprtea, si esta falla termina el programa*/

        printf("Ingrese fecha de la carpeta\n");
        while (1) {
            scanf(" %[^\n]", palabra);
            if (strlen(palabra) == 0) {
                printf("La fecha no puede quedar vacía. Intente de nuevo:\n");
            } else if (strlen(palabra) > 50) {
                printf("La fecha es demasiada larga. Intente de nuevo:\n");
            } else {
                break;
            }
        }
        nuevaCarpeta->fecha = (char *)malloc(strlen(palabra) + 1);
        if (nuevaCarpeta->fecha == NULL) {
            printf("Error al asignar memoria para la fecha\n");
            free(nuevaCarpeta);
            return;
        }        
        strcpy(nuevaCarpeta->fecha, palabra); 
        
        printf("Ingrese descripcion de la carpeta\n");
        while (1) {
            scanf(" %[^\n]", palabra);
            if (strlen(palabra) == 0) {
                printf("La descripcion no puede quedar vacía. Intente de nuevo:\n");
            } else if (strlen(palabra) > 200) {
                printf("La descripcion es demasiado larga. Intente de nuevo:\n");
            } else {
                break;
            }
        }
        nuevaCarpeta->descripcion = (char *)malloc(strlen(palabra) + 1);
        if (nuevaCarpeta->descripcion == NULL) {
        printf("Error al asignar memoria para la descripcion\n");
        free(nuevaCarpeta->fecha);
        free(nuevaCarpeta);
        return;
    }        
        strcpy(nuevaCarpeta->descripcion, palabra);  
        
        printf("Ingrese el tipo de dato, ya sea \n 1 = Declaraciones \n 2 = Pruebas Generales  \n 3 = Diligencias \n 4 = Denuncia");
        while (1) {
            if (scanf("%i", &tipoDato) != 1) {
                printf("Tipo de dato inválido. Intente nuevamente:\n");
                while (getchar() != '\n'); 
            } else if (tipoDato >= 1 && tipoDato <= 4){
                break;
            } else{
                printf("Tipo de dato fuera de rango, intente nuevamente\n");
            }
        }
             
        
        nuevaCarpeta->tipoDeDato = tipoDato;
        
        nuevaCarpeta->datosPersona = NULL;
        nuevaCarpeta->datosDiligencias  = NULL;
        nuevaCarpeta->datosDenuncia  = NULL;        
        
        printf("Ingrese RUC de la causa a la que desea asociar esta carpeta:\n");
        while(1){
            scanf(" %[^\n]", palabra);        
            if(strlen(palabra) == 0){
                printf("El RUC  no puede quedar vacio, intente nuevamente\n");
            } else if(strlen(palabra) > 20){
                printf("El RUC es demasiado largo, intente nuevamente\n");
            } else{
                break;
            }
        }
        struct nodoCausas *actual = ministerio->causas;
        int encontrado = 0;
        
        
        while(actual != NULL){
            if(strcmp(actual->datosCausa->ruc, palabra) == 0){
                agregarCarpetaInvestigativa(&actual->datosCausa->datosCarpetas, nuevaCarpeta);
                printf("La carpeta investigativa fue agregada correctamente.\n");
                encontrado = 1;
                break;
            }
            actual = actual->siguiente;
        }
        if(encontrado == 0){
            printf("No se encontro ninguna causa con ese RUC\n");
            free(nuevaCarpeta->fecha);
            free(nuevaCarpeta->descripcion);
            free(nuevaCarpeta);
        }
    } 
    else if(opcion == 4){
            char ruc[30];
            
            printf("Ingrese RUC de la causa.\n");
            while(1){
                scanf(" %[^\n]", ruc);        
                if(strlen(ruc) == 0){
                    printf("El RUC  no puede quedar vacio, intente nuevamente\n");
                } else if(strlen(ruc) > 20){
                    printf("El RUC es demasiado largo, intente nuevamente\n");
                } else{
                    break;
                }
            }
            
            struct denuncia *denunciaAsociada = buscarDenunciaPorRuc(ruc);
            
            if(denunciaAsociada == NULL){
                printf("No se encontro denuncia con ese RUC\n");
                return;
            }
            
            struct causa *nuevaCausa = (struct causa *)malloc(sizeof(struct causa));
            if(nuevaCausa == NULL){
                printf("Error al asignar memoria\n");
                return;
            }
            nuevaCausa->ruc = malloc(strlen(ruc) + 1);
            if (nuevaCausa->ruc == NULL) {
                printf("Error al asignar memoria para el RUC\n");
                free(nuevaCausa);
                return;
            }
            
            strcpy(nuevaCausa->ruc, ruc);
            nuevaCausa->denuncia = denunciaAsociada;
            nuevaCausa->datosCarpetas = NULL;
            nuevaCausa->involucrados = NULL;
            nuevaCausa->tamInvolucrados = 0;
            nuevaCausa->estadoCausa = 2;
            nuevaCausa->sentencia = NULL;
            
            agregarCausa(&ministerio->causas, nuevaCausa);
            printf("Causa agregada correctamente\n");
        }
        
        else if(opcion == 5){
            
            char palabra[100];
            int involucradosNuevos, i, tipo;
            struct causa *causaDestinada;
            struct involucrado *nuevoInvolucrado;
            struct persona *personaEncontrada;
            struct datosImputados *datosImp;
            
            printf("Ingrese el RUC de la causa a la que desea agregar el o los involucrados\n");
            getchar();
            
            while(1){
                scanf("%[^\n]", palabra);
                getchar();
                if(strlen(palabra) == 0){
                    printf("El RUC no puede quedar vacio, intente nuevamente\n");
                } else if(strlen(palabra) > 20){
                    printf("El RUC es demasiado largo, intente nuevamente\n");
                } else {
                    break;
                }
            }
            
            causaDestinada = buscarCausaPorRuc(palabra);
            if(causaDestinada == NULL){
                printf("No se encontro una causa con ese RUC\n");
                return;
            }
            
            printf("Ingrese la cantidad de involucrados a agregar\n");
            scanf("%i", &involucradosNuevos);
            getchar();
  
  
            for(i = 0; i < involucradosNuevos; i++){
                
                nuevoInvolucrado = (struct involucrado *)malloc(sizeof(struct involucrado));
                if(nuevoInvolucrado == NULL){
                    printf("Error al asignar memoria");
                    return;
                }
                
                printf("Ingrese el RUT del %i° involucrado\n", i + 1);
                while(1){
                    scanf(" %[^\n]", palabra);
                    getchar();
                    personaEncontrada = buscarPersonaPorRut(ministerio->personas, palabra);
                    
                    if(strlen(palabra) == 0){
                        printf("El RUT no puede estar vacio, intente nuevamente\n");
                    } else if(personaEncontrada == NULL){
                        printf("No se encontro una persona con ese RUT, intente nuevamente\n");
                    } else{
                        break;
                    }
                }
                
                nuevoInvolucrado->persona = personaEncontrada;
                
                printf("Seleccione el tipo de involucrado:\n");
                printf("1 = victima, 2 = imputado, 3 = fiscal, 4 = juez\n");
                while(1){
                    if(scanf("%i",&tipo) != 1){
                        printf("Entrada invalida, ingrese numero entre 1 y 4\n");
                        while(getchar() != '\n');
                    } else if(tipo >= 1 && tipo <= 4){
                        break;
                    } else {
                        printf("Entrada invalida, ingrese numero entre 1 y 4\n");
                        while(getchar() != '\n');
                    }
                }
                
                nuevoInvolucrado->tipoInvolucrado = tipo;
                
                if(tipo == 2){
                    datosImp = (struct datosImputados *)malloc(sizeof(struct datosImputados));
                    if(datosImp == NULL){
                        printf("Error al asignar memoria");
                        return;
                    }
                    
                    while (1) {
                        printf("Ingrese la declaración del imputado:\n");
                        scanf(" %[^\n]", palabra);
                        if (strlen(palabra) == 0) {
                            printf("La declaración no puede quedar vacía, intente nuevamente.\n");
                        } else {
                            break;
                        }
                    }
                    datosImp->declaracion = (char *)malloc(strlen(palabra) + 1);
                    strcpy(datosImp->declaracion, palabra);
                    
                    printf("Ingrese la medida cautelar (1=Prisión Preventiva, 2=Arraigo nacional, 3=Firma periódica, 4=Orden de alejamiento, 5=Arresto domiciliario, 6=Libertad bajo fianza, 7=Ninguna):\n");
                    while (1) {
                        if(scanf("%d", &datosImp->medidasCautelar) != 1){
                            
                            printf("Entrada inválida, ingrese un número entre 1 y 7\n");
                            while(getchar() != '\n');
                        } else if(datosImp->medidasCautelar >= 1 && datosImp->medidasCautelar <= 7){
                            break;
                        } else {
                            printf("Numero fuera de rango, intente nuevamente:\n");
                            while(getchar() != '\n');
                        }
                    }
                

                    while (1) {
                        printf("Ingrese la fecha de inicio de la medida (formato: DD/MM/AAAA):\n");
                        scanf(" %[^\n]", palabra);
                        if (strlen(palabra) == 0) {
                            printf("La fecha no puede quedar vacía, intente nuevamente.\n");
                        } else {
                            break;
                        }
                    }
                    datosImp->fechaInicioMedida = (char *)malloc(strlen(palabra) + 1);
                    strcpy(datosImp->fechaInicioMedida, palabra);
                

                    while (1) {
                        printf("Ingrese la fecha de fin de la medida (formato: DD/MM/AAAA):\n");
                        scanf(" %[^\n]", palabra);
                        if (strlen(palabra) == 0) {
                            printf("La fecha no puede quedar vacía, intente nuevamente.\n");
                        } else {
                            break;
                        }
                    }
                    datosImp->fechaFinMedida = (char *)malloc(strlen(palabra) + 1);
                    strcpy(datosImp->fechaFinMedida, palabra);
                

                    printf("Ingrese el estado procesal (1=Medida cautelar, 2=Formalizado, 3=Sobreseído):\n");
                    while (1) {
                        if (scanf("%d", &datosImp->estadoProcesal) != 1) {
                            printf("Entrada inválida. Ingrese un número entre 1 y 3:\n");
                            while (getchar() != '\n'); 
                        } else if (datosImp->estadoProcesal >= 1 && datosImp->estadoProcesal <= 3) {
                            while (getchar() != '\n'); 
                            break;
                        } else {
                            printf("Número fuera de rango. Intente nuevamente:\n");
                        }
                    }
                    nuevoInvolucrado->datosImputados = datosImp;
                } else{
                
                nuevoInvolucrado->datosImputados = NULL;
                
                }
                
                agregarInvolucrado(causaDestinada, nuevoInvolucrado);
                printf("Involucrado agregado correctamente\n");
            } 
        }
        else{
            printf("Opcion invalida, intente nuevamente.\n");
        }
    }

/*Agregar buffers */
